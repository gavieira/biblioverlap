#' Adding logo biblioverlap's plots
#'
#' @description
#' Helper function to finalize biblioverlap's plots. It basically adds the package's logo to the plot passed as argument. Except for `logo_path` and `alpha`, all its parameters are compatible with [`grid::grid.raster`]. Check its documentation for more info.
#'
#' @param plot - plot to add logo
#' @param logo_path - path to logo .png file
#' @param alpha - logo transparency
#' @param width - logo width
#' @param heigth - logo height
#' @param x - logo x position
#' @param y - logo y position
#' @param just - logo justification. First value specifies horizontal justification and second value specifies vertical justification. Possible string values are: "left", "right", "centre", "center", "bottom", and "top". For numeric values, 0 means left alignment and 1 means right alignment.
#' @param interpolate - logical value indicating if image should be linearly interpolated
#' @param ... -  - arguments to be passed down to [`grid::grid.raster`]
#'
#' @return a grid graphical object ("grob") containing both logo and its plotting position
#'
#' @noRd
#'
add_logo_to_plot <- function(plot,
                             logo_path = system.file("biblioverApp", "www", "biblioverlap_sticker.png", package = "biblioverlap"),
                             alpha = 0.2,
                             width = grid::unit(100, 'pt'),
                             height = grid::unit(125, 'pt'),
                             x = grid::unit(0.99, 'npc'),
                             y = grid::unit(0.99, 'npc'),
                             just = c('right', 'top'),
                             interpolate = TRUE,
                             ... ) {

  # Getting graphics device
  previous_device <- grDevices::dev.cur()

  # Set up null graphics device to avoid unintentional plotting
  grDevices::pdf(NULL)

  # Printing plot
  print(plot)

  # Getting logo
  logo_raw <- png::readPNG(logo_path) #Importing logo into R
  logo <- matrix(grDevices::rgb(logo_raw[,,1],logo_raw[,,2],logo_raw[,,3], logo_raw[,,4] * alpha), nrow=dim(logo_raw)[1]) #Adding transparency to logo - source: https://stackoverflow.com/questions/11357926/r-add-alpha-value-to-png-image

  # Ploting logo
  grid::grid.raster(logo,
              width = width,
              height = height,
              x = x,
              y = y,
              just = just,
              interpolate = interpolate,
              ...)

  #Generate combined plot
  combined_plot <- grid::grid.grab(wrap.grobs = TRUE )

  #Generate final plot (ggplot-like object)
  final_plot <- cowplot::ggdraw() +
    cowplot::draw_plot(combined_plot)

  # Go back to previous graphics device
  grDevices::dev.set(previous_device)

  #Return the final graphical object
  return( final_plot )
}



#' Extracting list of uuid columns from biblioverlap results
#'
#' @description
#' Helper function to [plot_venn()] and [plot_upset()] that extracts overlapping data stored in the UUID column.
#'
#' @param db_list - list of matched dataframes (with UUID column added by biblioverlap)
#'
#' @return - a list containing only the UUID data
#' @noRd
#'
get_uuid_list <- function(db_list) {
  return( lapply(db_list, function(db) db$UUID) )
}


#' Plotting biblioverlap's matching summary
#'
#' @param matching_summary_df - summary of matching process generated by [`biblioverlap`]
#' @param add_logo - boolean specifying whether to add package logo to plot or not. Default: TRUE
#' @param text_size - text size of plot elements (like axes names and legend). Default: 15
#' @param ... - additional arguments passed down to [`ggplot2::geom_text`]
#'
#' @return a barplot summary of the matching results
#'
#' @importFrom rlang .data
#' @export
#'
#' @examples
#' #Running document-level matching procedure
#' biblioverlap_results <- biblioverlap(ufrj_bio_0122[1:2])
#'
#' #Checking biblioverlap results (summary table)
#' biblioverlap_results$summary
#'
#' #Plotting the matching summary
#' plot_matching_summary(biblioverlap_results$summary)
#'
plot_matching_summary <- function(matching_summary_df, add_logo = TRUE, text_size = 15, ...) {
  summary_plot <- matching_summary_df %>%
    ggplot2::ggplot(ggplot2::aes(x = .data$category, y = .data$n_docs, fill = .data$doc_subset)) +
    ggplot2::geom_bar(stat = 'identity', position = 'stack') +
    ggplot2::geom_text(ggplot2::aes(label = paste0(.data$n_docs," (",.data$perc_inside_category,"%)")), position = ggplot2::position_stack(vjust = 0.5), ... ) +
    ggplot2::theme(text=ggplot2::element_text(size= text_size))

  if (add_logo) {
    return(add_logo_to_plot(summary_plot))
  }

  return(summary_plot)
}


#' Plotting Venn Diagram from biblioverlap results
#'
#' @param db_list - list of matched dataframes (with UUID column added by [`biblioverlap`])
#' @param add_logo - boolean specifying whether to add package logo to plot or not. Default: TRUE
#' @param ... - Additional arguments that can be passed down to [`ggVennDiagram::ggVennDiagram`]
#'
#' @return a Venn Diagram representation of document overlap between the input datasets
#' @export
#'
#' @examples
#' #Running document-level matching procedure
#' biblioverlap_results <- biblioverlap(ufrj_bio_0122[1:2])
#'
#' #Checking biblioverlap results (db_list)
#' lapply(biblioverlap_results$db_list, head, n=1)
#'
#' #Plotting the Venn diagram
#' plot_venn(biblioverlap_results$db_list)
#'
plot_venn <- function(db_list, add_logo = TRUE, ...) {
  uuid <- get_uuid_list(db_list)
  venn <- ggVennDiagram::ggVennDiagram(uuid, ...) +
    ggplot2::scale_fill_gradient(low = "#A7C7E7", high = "#08306B") +
    ggplot2::scale_x_continuous(expand = ggplot2::expansion(mult = .2))

  if (add_logo) {
    return(add_logo_to_plot(venn))
  }

  return ( venn )
}

#' Plotting UpSet plot from biblioverlap results
#'
#' @param db_list - list of matched dataframes (with UUID column added by [`biblioverlap`])
#' @param add_logo - boolean specifying whether to add package logo to plot or not. Default: TRUE
#' @param ... - arguments to be passed down to [`UpSetR::upset`]
#'
#' @return a UpSet plot representation of document overlap between the input datasets
#' @export
#'
#' @examples
#' #Running document-level matching procedure
#' biblioverlap_results <- biblioverlap(ufrj_bio_0122[1:2])
#'
#' #Checking biblioverlap results (db_list)
#' lapply(biblioverlap_results$db_list, head, n=1)
#'
#' #Plotting the UpSet plot
#' plot_upset(biblioverlap_results$db_list)
#'
plot_upset <- function(db_list, add_logo = TRUE, ...) {
  uuid <- get_uuid_list(db_list)
  upset <- UpSetR::upset(UpSetR::fromList(uuid),
                         main.bar.color = "#08306B",
                         sets.bar.color = "#08306B",
                         att.color = "steelblue",
                         shade.color = "steelblue",
                         matrix.color = "#08306B",
                         ...)

  if (add_logo) {
    return(add_logo_to_plot(upset))
  }

  return ( upset )
}


#' Shiny App for the biblioverlap package
#'
#' @param port - port of the application
#' @param max_upload_size - max upload size of documents (in MB) - Default 1000
#' @param launch.browser - launch on browser - Default = TRUE
#'
#' @return opens a instance of the biblioverlap UI
#' @export
#'
#' @examples
#' #Running the ShinyApp
#' biblioverApp()
#'
biblioverApp <- function(port = NULL, max_upload_size = 1000, launch.browser = TRUE) {
  if (interactive()) {
    options(shiny.maxRequestSize = max_upload_size * 1024 * 1024)
    shiny::shinyAppDir(
      system.file("biblioverApp", package = "biblioverlap"),
      options = list(port = port, launch.browser = launch.browser)
    )
  } else {
    message("This function is intended for interactive sessions.")
    return(NULL)
  }
}
